# 高效能計算作業

## 變數說明
假設矩陣乘法為 C = A * B
A 矩陣是 m x n 的矩陣
B 矩陣式 n x p 的矩陣
C 是 m x p 的矩陣

i 是 C 矩陣的 row 索引值
j 是 C 矩陣的 column 索引值
k 表示 A 的 row 與 B 的 column

下方算法中， 
i 用於遍歷 C 的 row
j 用於遍歷 C 的 column
k 用於計算 A row 跟 B column 的點積

所以會出現:
```c++=
for (i = 0; i < m; i++)
  for (j = 0; j < p; j++) {
    C[i][j] = 0;
    for (k = 0; k < n; k++)
      C[i][j] += A[i][k] * B[k][j];
}
```

以 5 * 5 矩陣為例子，他在執行上的步驟為:
(k 因為是最內層，相當於每次都一定會執行完畢，所以 k 不特別列出，而是每步驟都會執行 0 ~ 5)
步驟 1: i = 0, j = 0

C[0][0] = A[0][0]*B[0][0] + A[0][1]*B[1][0] + A[0][2]*B[2][0] + A[0][3]*B[3][0] + A[0][4]*B[4][0]

步驟 2: i = 0, j = 1

C[0][1] = A[0][0]*B[0][1] + A[0][1]*B[1][1] + A[0][2]*B[2][1] + A[0][3]*B[3][1] + A[0][4]*B[4][1]

步驟 3-5: 繼續計算 C[0][2], C[0][3], C[0][4]
步驟 6: i = 1, j = 0

C[1][0] = A[1][0]*B[0][0] + A[1][1]*B[1][0] + A[1][2]*B[2][0] + A[1][3]*B[3][0] + A[1][4]*B[4][0]

步驟 7: i = 1, j = 1

C[1][1] = A[1][0]*B[0][1] + A[1][1]*B[1][1] + A[1][2]*B[2][1] + A[1][3]*B[3][1] + A[1][4]*B[4][1]

步驟 8-10: 繼續計算 C[1][2], C[1][3], C[1][4]
... 過程繼續 ...
步驟 21: i = 4, j = 0

C[4][0] = A[4][0]*B[0][0] + A[4][1]*B[1][0] + A[4][2]*B[2][0] + A[4][3]*B[3][0] + A[4][4]*B[4][0]

步驟 22: i = 4, j = 1

C[4][1] = A[4][0]*B[0][1] + A[4][1]*B[1][1] + A[4][2]*B[2][1] + A[4][3]*B[3][1] + A[4][4]*B[4][1]

步驟 23-25: 計算 C[4][2], C[4][3], C[4][4]

## 五種算法
1. Loop ijk
實際執行:
![image](https://hackmd.io/_uploads/Hy-6HUTJye.png)

最簡單暴力的方式，直接用 loop 的方式實現現代提到的矩陣乘法
優點: 簡單方便
缺點: 對於 A、B 矩陣要多次訪問，同時因為不符合系統矩陣的儲存邏輯(通常是 column 為主)，在 B 的訪問上就會增加 IO Bound(IO 瓶頸)

example: 上面範例講解

2. Loop-reordering
實際執行:
![image](https://hackmd.io/_uploads/ryrNU8akyl.png)

將訪問順序調整了一下，並且讓最內層五次迴圈改為簡單的只訪問 B 的 Column 增加效能
這裡增加效能的原因是因為 A 被拿到外面，他的循環訪問次數只剩五次，若為原先的 ijk 算法，則會變成 25 次。

```c++=
for (i = 0; i < 5; i++)
  for (k = 0; k < 5; k++) {
    temp = A[i][k]; // A 被拿到外面來
    for (j = 0; j < 5; j++)
      C[i][j] += temp * B[k][j];
  }
```

步驟 1: i = 0, k = 0
```
temp = A[0][0]
C[0][0] += temp * B[0][0]
C[0][1] += temp * B[0][1]
C[0][2] += temp * B[0][2]
C[0][3] += temp * B[0][3]
C[0][4] += temp * B[0][4]
```
步驟 2: i = 0, k = 1
```
temp = A[0][1]
C[0][0] += temp * B[1][0]
C[0][1] += temp * B[1][1]
C[0][2] += temp * B[1][2]
C[0][3] += temp * B[1][3]
C[0][4] += temp * B[1][4]
```
但缺點也相當明顯，C 的 Input 次數依然高，而且寫入次數也增加了 (5->25次)

3. Matrix-column
實際執行:
![image](https://hackmd.io/_uploads/S1VsL8pJkg.png)

將矩陣 x 矩陣乘法轉為矩陣 x 向量乘法
將 C 提到外圈，減少 C 的訪問次數，並且讓整體結構改為只有 A 會有大量訪問，而 B 則是減少了大量訪問的問題，這樣的做法在 B 矩陣比較大(大很多)的時候會有明顯優化，但在一般狀況下並不會有特別差異，甚至因為 A 的存取模式修改造成可能效能略遜於 ijk 算法
```C++=
for (j = 0; j < 5; j++) {
  for (i = 0; i < 5; i++) {
    C[i][j] = 0;
    for (k = 0; k < 5; k++)
      C[i][j] += A[i][k] * B[k][j];
  }
}
```
步驟 1: j = 0 (計算 C 的第一列)
```
C[0][0] = A[0][0]*B[0][0] + A[0][1]*B[1][0] + A[0][2]*B[2][0] + A[0][3]*B[3][0] + A[0][4]*B[4][0]
C[1][0] = A[1][0]*B[0][0] + A[1][1]*B[1][0] + A[1][2]*B[2][0] + A[1][3]*B[3][0] + A[1][4]*B[4][0]
C[2][0] = A[2][0]*B[0][0] + A[2][1]*B[1][0] + A[2][2]*B[2][0] + A[2][3]*B[3][0] + A[2][4]*B[4][0]
C[3][0] = A[3][0]*B[0][0] + A[3][1]*B[1][0] + A[3][2]*B[2][0] + A[3][3]*B[3][0] + A[3][4]*B[4][0]
C[4][0] = A[4][0]*B[0][0] + A[4][1]*B[1][0] + A[4][2]*B[2][0] + A[4][3]*B[3][0] + A[4][4]*B[4][0]
```
步驟 2: j = 1 (計算 C 的第二列)
```
C[0][1] = A[0][0]*B[0][1] + A[0][1]*B[1][1] + A[0][2]*B[2][1] + A[0][3]*B[3][1] + A[0][4]*B[4][1]
C[1][1] = A[1][0]*B[0][1] + A[1][1]*B[1][1] + A[1][2]*B[2][1] + A[1][3]*B[3][1] + A[1][4]*B[4][1]
C[2][1] = A[2][0]*B[0][1] + A[2][1]*B[1][1] + A[2][2]*B[2][1] + A[2][3]*B[3][1] + A[2][4]*B[4][1]
C[3][1] = A[3][0]*B[0][1] + A[3][1]*B[1][1] + A[3][2]*B[2][1] + A[3][3]*B[3][1] + A[3][4]*B[4][1]
C[4][1] = A[4][0]*B[0][1] + A[4][1]*B[1][1] + A[4][2]*B[2][1] + A[4][3]*B[3][1] + A[4][4]*B[4][1]
```
4. 不複製子矩陣的 block
實際執行:
![image](https://hackmd.io/_uploads/BkXTUUTy1x.png)

簡單來說就是將原始矩陣拆分成小矩陣來進行乘法，只是這是在原始矩陣上直接操作，不使用額外暫存來存取切割後的子矩陣，效能會優於前面的幾個算法，但更大的問題在於子矩陣大小如何切，以及是否需要處裡邊緣矩陣(假設矩陣切成 2 x 2 大小，但我們原先的總矩陣大小是 5 x 5，這會造成最後有 1x1 大小的矩陣沒有被訪問，若沒有處裡好會造成計算錯誤)
之所以效能會優化是因為所有資料都會依照子矩陣大小先存到暫存裡面，在訪問這些資料的時候我就不用每次都要回到原先的記憶體空間進行訪問，而是直接跟暫存要就可以，減少了要資料的時間(暫存就是 CPU 可以用來暫時存取的 RAM 空間)
但會增加暫存空間的需求，所以在 CPU 暫存不足或者子矩陣大小切超出暫存空間上限的時候會爆掉。
```
for (i = 0; i < 5; i += BLOCK_SIZE)
  for (j = 0; j < 5; j += BLOCK_SIZE)
    for (k = 0; k < 5; k += BLOCK_SIZE)
      // 對子矩陣 A[i:i+BLOCK_SIZE][k:k+BLOCK_SIZE] 和
      // B[k:k+BLOCK_SIZE][j:j+BLOCK_SIZE] 執行矩陣乘法
      // 結果累加到 C[i:i+BLOCK_SIZE][j:j+BLOCK_SIZE]
```
步驟 1: i = 0, j = 0, k = 0
```
計算：
C[0:2][0:2] += A[0:2][0:2] * B[0:2][0:2]
具體操作：
C[0][0] += A[0][0]*B[0][0] + A[0][1]*B[1][0]
C[0][1] += A[0][0]*B[0][1] + A[0][1]*B[1][1]
C[1][0] += A[1][0]*B[0][0] + A[1][1]*B[1][0]
C[1][1] += A[1][0]*B[0][1] + A[1][1]*B[1][1]
```

步驟 2: i = 0, j = 0, k = 2
```
計算：
C[0:2][0:2] += A[0:2][2:4] * B[2:4][0:2]
```
步驟 3: i = 0, j = 0, k = 4
```
計算：
C[0:2][0:2] += A[0:2][4:5] * B[4:5][0:2]
（注意：這裡的塊大小變成了 1x1，因為矩陣邊界只剩下一個元素，這個要特別寫或者某些程式語言本身就支援這件事情，不然迴圈處裡上會 Out of Range）
```
5. 複製子矩陣的 block
實際執行:
![image](https://hackmd.io/_uploads/S1ZkPL6kye.png)

跟上面邏輯類似，只是切出來的子矩陣會直接丟到內存去進行存放，在 RAM 足夠的狀況下這件事情能夠減少 CPU 效能並且有效利用到 CPU 的向量化指令計算，同時也能夠更好的去利用到暫存的預存取機制，增加效能。
因為他是在連續內存的狀況下進行操作，在緩存的命中率上會大幅提升(這裡的關聯性我沒有讀很懂)
同時因為連續內存的訪問方式，會相較於跨越式的訪問方式比較高效率(矩陣都是一堆陣列疊起來的，如果你要跨 row 訪問會需要跨陣列訪問)

```C++=
for (i = 0; i < 5; i += BLOCK_SIZE)
  for (j = 0; j < 5; j += BLOCK_SIZE)
    for (k = 0; k < 5; k += BLOCK_SIZE) {
      // 複製 A 和 B 的子矩陣到臨時區域
      copy_submatrix(A, temp_A, i, k, BLOCK_SIZE);
      copy_submatrix(B, temp_B, k, j, BLOCK_SIZE);
      // 在臨時區域執行子矩陣乘法
      multiply_submatrices(temp_A, temp_B, temp_C, BLOCK_SIZE);
      // 將結果累加回 C
      add_to_submatrix(C, temp_C, i, j, BLOCK_SIZE);
    }
```

步驟 1: i = 0, j = 0, k = 0
```
複製 A[0:2][0:2] 到 temp_A
複製 B[0:2][0:2] 到 temp_B
計算 temp_C = temp_A * temp_B
將 temp_C 加到 C[0:2][0:2]
```
步驟 2: i = 0, j = 0, k = 2
```
複製 A[0:2][2:4] 到 temp_A
複製 B[2:4][0:2] 到 temp_B
計算 temp_C = temp_A * temp_B
將 temp_C 加到 C[0:2][0:2]
```
步驟 3: i = 0, j = 0, k = 4
（注意：這裡的塊大小變成了 1x1）
```
複製 A[0:2][4:5] 到 temp_A
複製 B[4:5][0:2] 到 temp_B
計算 temp_C = temp_A * temp_B
將 temp_C 加到 C[0:2][0:2]
```
